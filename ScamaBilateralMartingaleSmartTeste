//+------------------------------------------------------------------+
//|                           GridFractalXAU_Adaptive_Enhanced.mq5  |
//|                    Estratégia: Grid adaptativo com reversão      |
//|   Lógica: Alterna entre BUY e SELL baseado em níveis anteriores  |
//|   + Stop financeiro e continuidade de vendas em queda            |
//+------------------------------------------------------------------+
#property strict
#property version   "2.10"
#property description "EA de grid adaptativo com stop financeiro e lógica de vendas em queda."

#include <Trade/Trade.mqh>
#include <Trade/PositionInfo.mqh>

CTrade Trade;
CPositionInfo PositionInfo;

// ============================= Inputs ============================= //
input string Inp____Geral        = "==== Geral ====";
input long   InpMagic            = 20250816;    // Magic Number
input int    InpSlippage         = 5;           // Slippage máximo (points)

input string Inp____Pipagem      = "==== Pipagem ====";
input int    InpPipInPoints      = 10;          // Quantos points valem 1 pip (padrão ouro: 10)

input string Inp____Strategy     = "==== Estratégia Adaptativa ====";
input double InpInitialLot       = 0.01;        // Lote inicial
input double InpIncreasedLot     = 0.02;        // Lote após trigger
input int    InpStepPips         = 15;          // Espaçamento entre ordens (pips)
input int    InpTPPips           = 15;          // TP individual (pips)
input int    InpTriggerAfterOrders = 3;         // Após quantas ordens começar lógica adaptativa
input int    InpMaxTotalOrders   = 20;          // Máximo de ordens totais (0 = infinito)

input string Inp____StopFinanceiro = "==== Stop Financeiro ====";
input bool   InpEnableFinancialStop = true;     // Ativar stop financeiro
input double InpFinancialStopLoss = 150.0;      // Stop financeiro em $ (negativo)
input bool   InpAutoRestart      = true;        // Reiniciar automaticamente após stop

input string Inp____VendasQueda  = "==== Vendas em Queda ====";
input bool   InpEnableSellOnDown = true;        // Continuar vendas quando descendo
input double InpSellLotOnDown    = 0.02;        // Lote para vendas em queda
input int    InpMinSellDistance  = 10;          // Distância mínima entre vendas (pips)

input string Inp____Volume       = "==== Volume Progressivo ====";
input bool   InpEnableProgressiveLot = true;    // Ativar volume progressivo
input int    InpOrdersPerLevel   = 10;          // Ordens por nível antes de aumentar volume
input double InpLotIncrement     = 0.01;        // Incremento de volume por nível

input string Inp____Reversal     = "==== Lógica de Reversão ====";
input bool   InpEnableReversal   = true;        // Ativar reversão automática
input int    InpReversalLookback = 5;           // Quantos níveis anteriores verificar para reversão

// ============================ Variáveis =========================== //
bool   g_initialized = false;
string g_symbol;
int    g_digits;
double g_point;
double g_pip;

// Estrutura para armazenar histórico de ordens
struct OrderLevel {
    double price;
    ENUM_POSITION_TYPE type;
    datetime time;
    bool is_active;
    double lot_used;
};

// Arrays para histórico
OrderLevel g_orderHistory[];
int g_historyCount = 0;

// Estado da estratégia
enum ENUM_STRATEGY_MODE {
    MODE_INITIAL,      // Modo inicial (primeiras ordens)
    MODE_ADAPTIVE_BUY, // Modo adaptativo - comprando
    MODE_ADAPTIVE_SELL // Modo adaptativo - vendendo
};

ENUM_STRATEGY_MODE g_currentMode = MODE_INITIAL;
double g_lastAnchor = 0.0;
int g_totalOrders = 0;
double g_lastSellPrice = 0.0;  // Última venda para controlar distância

// Contadores para volume progressivo
int g_buyOrderCount = 0;    // Contador de ordens BUY
int g_sellOrderCount = 0;   // Contador de ordens SELL

// Controle do ciclo
bool g_cycleActive = true;
double g_cycleStartEquity = 0.0;

// ============================ Funções Auxiliares ========================== //

// Converte pips para preço
double PipToPrice(const int pips) 
{ 
   return(pips * g_pip); 
}

// Normaliza preço
double NormalizePrice(const double price) 
{ 
   return(NormalizeDouble(price, g_digits)); 
}

// Conta posições totais
int CountAllPositions()
{
   int total = 0;
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      if(PositionInfo.SelectByIndex(i))
      {
         if(PositionInfo.Magic() != InpMagic) continue;
         if(PositionInfo.Symbol() != g_symbol) continue;
         total++;
      }
   }
   return total;
}

// Conta posições por tipo
int CountPositions(const ENUM_POSITION_TYPE dir)
{
   int total = 0;
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      if(PositionInfo.SelectByIndex(i))
      {
         if(PositionInfo.Magic() != InpMagic) continue;
         if(PositionInfo.Symbol() != g_symbol) continue;
         if(PositionInfo.PositionType() == dir) total++;
      }
   }
   return total;
}

// Calcula P&L atual
double GetCurrentPnL()
{
   double total_profit = 0.0;
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      if(PositionInfo.SelectByIndex(i))
      {
         if(PositionInfo.Magic() != InpMagic) continue;
         if(PositionInfo.Symbol() != g_symbol) continue;
         total_profit += PositionInfo.Profit() + PositionInfo.Swap() + PositionInfo.Commission();
      }
   }
   return total_profit;
}

// Fecha todas as posições
void CloseAllPositions()
{
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      if(PositionInfo.SelectByIndex(i))
      {
         if(PositionInfo.Magic() != InpMagic) continue;
         if(PositionInfo.Symbol() != g_symbol) continue;
         
         Trade.PositionClose(PositionInfo.Ticket());
         Print("[CLOSE] Posição fechada: Ticket=", PositionInfo.Ticket(), " Tipo=", EnumToString(PositionInfo.PositionType()));
      }
   }
}

// Reinicia o ciclo
void RestartCycle()
{
   CloseAllPositions();
   
   // Reset variáveis
   g_currentMode = MODE_INITIAL;
   g_totalOrders = 0;
   g_buyOrderCount = 0;
   g_sellOrderCount = 0;
   g_historyCount = 0;
   g_lastSellPrice = 0.0;
   ArrayResize(g_orderHistory, 0);
   
   // Espera um pouco antes de reiniciar
   Sleep(1000);
   
   InitAnchor();
   g_cycleActive = true;
   g_cycleStartEquity = AccountInfoDouble(ACCOUNT_EQUITY);
   
   Print("[RESTART] Ciclo reiniciado! Nova equity base: ", g_cycleStartEquity);
}

// Adiciona nível ao histórico
void AddToHistory(double price, ENUM_POSITION_TYPE type, double lot_used)
{
   ArrayResize(g_orderHistory, g_historyCount + 1);
   g_orderHistory[g_historyCount].price = price;
   g_orderHistory[g_historyCount].type = type;
   g_orderHistory[g_historyCount].time = TimeCurrent();
   g_orderHistory[g_historyCount].is_active = true;
   g_orderHistory[g_historyCount].lot_used = lot_used;
   g_historyCount++;
   
   Print("[HISTORY] Adicionado nível: ", price, " Tipo: ", EnumToString(type), " Lote: ", lot_used, " Total: ", g_historyCount);
}

// Verifica se preço está descendo (baseado no anchor)
bool IsPriceMovingDown()
{
   MqlTick tick;
   if(!SymbolInfoTick(g_symbol, tick)) return false;
   
   return (tick.bid < g_lastAnchor);
}

// Verifica se deve fazer venda em queda
bool ShouldSellOnDown(double current_price)
{
   if(!InpEnableSellOnDown) return false;
   if(g_currentMode == MODE_INITIAL) return false; // Só após modo adaptativo
   if(!IsPriceMovingDown()) return false;
   
   // Verifica distância mínima da última venda
   if(g_lastSellPrice > 0.0)
   {
      double distance = MathAbs(current_price - g_lastSellPrice);
      double min_distance = PipToPrice(InpMinSellDistance);
      if(distance < min_distance) return false;
   }
   
   return true;
}

// Verifica se preço está próximo a níveis anteriores do tipo oposto
bool IsNearOppositeTypeLevel(double current_price, ENUM_POSITION_TYPE current_type)
{
   if(!InpEnableReversal || g_historyCount < InpReversalLookback) return false;
   
   ENUM_POSITION_TYPE opposite_type = (current_type == POSITION_TYPE_BUY) ? POSITION_TYPE_SELL : POSITION_TYPE_BUY;
   double tolerance = PipToPrice(InpStepPips) * 0.5; // Tolerância de meio step
   
   // Verifica os últimos níveis do tipo oposto
   int checked = 0;
   for(int i = g_historyCount - 1; i >= 0 && checked < InpReversalLookback; i--)
   {
      if(g_orderHistory[i].type == opposite_type)
      {
         double diff = MathAbs(current_price - g_orderHistory[i].price);
         if(diff <= tolerance)
         {
            Print("[REVERSAL] Preço ", current_price, " próximo ao nível ", opposite_type, " em ", g_orderHistory[i].price, " (diff: ", diff, ")");
            return true;
         }
         checked++;
      }
   }
   
   return false;
}

// Determina qual tipo de ordem abrir baseado na lógica adaptativa
ENUM_POSITION_TYPE GetNextOrderType(double current_price)
{
   // Modo inicial - sempre BUY (como no código original)
   if(g_currentMode == MODE_INITIAL)
   {
      return POSITION_TYPE_BUY;
   }
   
   // Verifica se deve reverter direção
   ENUM_POSITION_TYPE intended_type = (g_currentMode == MODE_ADAPTIVE_BUY) ? POSITION_TYPE_BUY : POSITION_TYPE_SELL;
   
   if(IsNearOppositeTypeLevel(current_price, intended_type))
   {
      // Reverte a direção
      ENUM_POSITION_TYPE new_type = (intended_type == POSITION_TYPE_BUY) ? POSITION_TYPE_SELL : POSITION_TYPE_BUY;
      g_currentMode = (new_type == POSITION_TYPE_BUY) ? MODE_ADAPTIVE_BUY : MODE_ADAPTIVE_SELL;
      
      Print("[STRATEGY] Reversão detectada! Mudando de ", EnumToString(intended_type), " para ", EnumToString(new_type));
      return new_type;
   }
   
   return intended_type;
}

// Calcula o lote a ser usado
double GetLotSize(ENUM_POSITION_TYPE type, bool is_sell_on_down = false)
{
   // Se é venda em queda, usa lote específico
   if(is_sell_on_down)
   {
      return InpSellLotOnDown;
   }
   
   if(!InpEnableProgressiveLot)
   {
      // Sistema antigo - baseado apenas no número total de ordens
      return (g_totalOrders < InpTriggerAfterOrders) ? InpInitialLot : InpIncreasedLot;
   }
   
   // Sistema novo - volume progressivo por tipo
   int current_count = 0;
   
   if(type == POSITION_TYPE_BUY)
   {
      current_count = g_buyOrderCount;
   }
   else
   {
      current_count = g_sellOrderCount;
   }
   
   // Calcula o nível de volume baseado em quantas ordens do mesmo tipo já foram abertas
   int volume_level = current_count / InpOrdersPerLevel;
   double lot = InpInitialLot + (volume_level * InpLotIncrement);
   
   // Garante um mínimo
   if(lot < InpInitialLot) lot = InpInitialLot;
   
   return lot;
}

// Abre posição
bool OpenPosition(ENUM_POSITION_TYPE type, bool is_sell_on_down = false)
{
   if(!g_cycleActive) return false;
   
   if(InpMaxTotalOrders > 0 && CountAllPositions() >= InpMaxTotalOrders) 
   {
      Print("[DEBUG] Máximo de ordens atingido:", InpMaxTotalOrders);
      return false;
   }
      
   MqlTick tick; 
   if(!SymbolInfoTick(g_symbol, tick)) 
   {
      Print("[DEBUG] Erro ao obter tick");
      return false;
   }
   
   double price, tp;
   double lot = GetLotSize(type, is_sell_on_down);
   
   if(type == POSITION_TYPE_BUY)
   {
      price = tick.ask;
      tp = NormalizePrice(price + PipToPrice(InpTPPips));
   }
   else
   {
      price = tick.bid;
      tp = NormalizePrice(price - PipToPrice(InpTPPips));
   }
   
   Trade.SetExpertMagicNumber(InpMagic);
   Trade.SetTypeFilling(ORDER_FILLING_FOK);
   
   bool ok = false;
   string comment = is_sell_on_down ? 
                   StringFormat("SellDown L%.2f", lot) : 
                   StringFormat("Grid %s L%.2f O%d", EnumToString(type), lot, g_totalOrders + 1);
   
   if(type == POSITION_TYPE_BUY)
   {
      ok = Trade.Buy(lot, g_symbol, price, 0.0, tp, comment);
   }
   else
   {
      ok = Trade.Sell(lot, g_symbol, price, 0.0, tp, comment);
   }
   
   if(ok)
   {
      Print("[SUCCESS] ", EnumToString(type), " executado: Preço=", price, " TP=", tp, " Lote=", lot, " SellDown=", is_sell_on_down);
      AddToHistory(price, type, lot);
      
      if(!is_sell_on_down)
      {
         g_totalOrders++;
      }
      
      // Atualiza contadores
      if(type == POSITION_TYPE_BUY)
      {
         g_buyOrderCount++;
      }
      else
      {
         g_sellOrderCount++;
         if(is_sell_on_down) g_lastSellPrice = price;
      }
      
      // Atualiza modo após trigger (apenas para ordens normais)
      if(!is_sell_on_down && g_totalOrders == InpTriggerAfterOrders)
      {
         g_currentMode = MODE_ADAPTIVE_BUY; // Começa modo adaptativo com BUY
         Print("[STRATEGY] Modo adaptativo ativado! Modo atual: ", EnumToString(g_currentMode));
      }
   }
   else
   {
      Print("[ERROR] Falha ao executar ", EnumToString(type), ": ", Trade.ResultRetcode(), " - ", Trade.ResultRetcodeDescription());
   }
   
   return ok;
}

// Inicializa anchor
void InitAnchor()
{
   MqlTick tick; 
   if(!SymbolInfoTick(g_symbol, tick)) return;
   
   g_lastAnchor = tick.ask;
   g_cycleStartEquity = AccountInfoDouble(ACCOUNT_EQUITY);
   
   // Abre primeira ordem
   OpenPosition(POSITION_TYPE_BUY);
}

// Verifica stop financeiro
bool CheckFinancialStop()
{
   if(!InpEnableFinancialStop) return false;
   
   double current_pnl = GetCurrentPnL();
   
   if(current_pnl <= -InpFinancialStopLoss)
   {
      Print("[FINANCIAL_STOP] Stop financeiro atingido! P&L: ", current_pnl, " Stop: ", -InpFinancialStopLoss);
      
      if(InpAutoRestart)
      {
         RestartCycle();
      }
      else
      {
         CloseAllPositions();
         g_cycleActive = false;
      }
      
      return true;
   }
   
   return false;
}

// Verifica se deve abrir próxima ordem
void TryOpenNextOrder()
{
   if(!g_cycleActive) return;
   
   MqlTick tick; 
   if(!SymbolInfoTick(g_symbol, tick)) return;
   
   double current_price = tick.ask;
   double step = PipToPrice(InpStepPips);
   
   // Lógica normal do grid (como no código original)
   double trigger_up = g_lastAnchor + step;
   double trigger_down = g_lastAnchor - step;
   
   bool should_open = false;
   ENUM_POSITION_TYPE next_type;
   
   if(current_price >= trigger_up)
   {
      // Preço subiu
      g_lastAnchor = trigger_up;
      next_type = GetNextOrderType(current_price);
      should_open = true;
   }
   else if(current_price <= trigger_down)
   {
      // Preço desceu
      g_lastAnchor = trigger_down;
      next_type = GetNextOrderType(current_price);
      should_open = true;
      
      // NOVA LÓGICA: Se desceu e estamos em modo adaptativo, 
      // adiciona uma venda extra de 0.02 se configurado
      if(should_open && ShouldSellOnDown(current_price))
      {
         OpenPosition(next_type); // Abre a ordem normal primeiro
         Sleep(100); // Pequena pausa
         OpenPosition(POSITION_TYPE_SELL, true); // Adiciona venda em queda
         return;
      }
   }
   
   if(should_open)
   {
      OpenPosition(next_type);
   }
}

// Exibe informações na tela
void PrintHUD()
{
   int buys = CountPositions(POSITION_TYPE_BUY);
   int sells = CountPositions(POSITION_TYPE_SELL);
   double current_pnl = GetCurrentPnL();
   double current_buy_lot = GetLotSize(POSITION_TYPE_BUY);
   double current_sell_lot = GetLotSize(POSITION_TYPE_SELL);
   string mode_str = "";
   
   switch(g_currentMode)
   {
      case MODE_INITIAL: mode_str = "INICIAL"; break;
      case MODE_ADAPTIVE_BUY: mode_str = "ADAPTATIVO (BUY)"; break;
      case MODE_ADAPTIVE_SELL: mode_str = "ADAPTATIVO (SELL)"; break;
   }
   
   string status_color = (current_pnl >= 0) ? "VERDE" : "VERMELHO";
   string stop_status = InpEnableFinancialStop ? 
                       StringFormat("ATIVO (%.0f/%.0f)", -current_pnl, InpFinancialStopLoss) : "INATIVO";
   
   Comment(
      "GridFractalXAU Enhanced — ", g_symbol, "\n",
      "Status: ", (g_cycleActive ? "ATIVO" : "PARADO"), " | Modo: ", mode_str, "\n",
      "P&L: $", DoubleToString(current_pnl, 2), " (", status_color, ")\n",
      "Stop Financeiro: ", stop_status, "\n",
      "Ordens: ", g_totalOrders, "/", (InpMaxTotalOrders > 0 ? IntegerToString(InpMaxTotalOrders) : "∞"), "\n",
      "BUYs: ", buys, " (", g_buyOrderCount, " total) | SELLs: ", sells, " (", g_sellOrderCount, " total)\n",
      "Próximo lote BUY: ", DoubleToString(current_buy_lot, 2), " | SELL: ", DoubleToString(current_sell_lot, 2), "\n",
      "Vendas em queda: ", (InpEnableSellOnDown ? "ATIVAS" : "INATIVAS"), " (Lote: ", DoubleToString(InpSellLotOnDown, 2), ")\n",
      "Step: ", InpStepPips, "p | TP: ", InpTPPips, "p | Distância mín vendas: ", InpMinSellDistance, "p\n",
      "Preço descendo: ", (IsPriceMovingDown() ? "SIM" : "NÃO"), "\n",
      "Anchor: ", DoubleToString(g_lastAnchor, g_digits), "\n",
      "Última venda: ", (g_lastSellPrice > 0 ? DoubleToString(g_lastSellPrice, g_digits) : "N/A")
   );
}

// ============================ Callbacks =========================== //
int OnInit()
{
   g_symbol = _Symbol;
   g_digits = (int)SymbolInfoInteger(g_symbol, SYMBOL_DIGITS);
   g_point = SymbolInfoDouble(g_symbol, SYMBOL_POINT);
   g_pip = InpPipInPoints * g_point;

   Trade.SetExpertMagicNumber(InpMagic);
   
   // Reset variáveis
   g_currentMode = MODE_INITIAL;
   g_totalOrders = 0;
   g_buyOrderCount = 0;
   g_sellOrderCount = 0;
   g_historyCount = 0;
   g_lastSellPrice = 0.0;
   g_cycleActive = true;
   ArrayResize(g_orderHistory, 0);
   
   InitAnchor();
   g_initialized = true;
   
   Print("EA GridFractalXAU Enhanced inicializado com sucesso.");
   return(INIT_SUCCEEDED);
}

void OnTick()
{
   if(!g_initialized) return;
   
   // Verifica stop financeiro primeiro
   if(CheckFinancialStop()) return;
   
   TryOpenNextOrder();
   PrintHUD();
}

void OnDeinit(const int reason)
{
   Comment("");
   Print("EA GridFractalXAU Enhanced finalizado. Razão: ", reason);
}

// ============================ Notas Principais ==================== //
// 1) INÍCIO COM BUY: EA sempre começa com ordens de compra (como original)
// 2) VENDAS EM QUEDA: Após modo adaptativo, adiciona SELLs de 0.02 quando desce
// 3) STOP FINANCEIRO: Ao atingir -$150, fecha tudo e reinicia ciclo
// 4) LÓGICA COMPLEMENTAR: Vendas em queda são ADICIONAIS à estratégia normal
// 5) AUTO RESTART: Reinicia automaticamente após stop financeiro
// 6) SEQUÊNCIA: BUY inicial → Modo adaptativo → BUY/SELL + vendas extras em queda
// 7) HISTÓRICO DETALHADO: Inclui lote usado em cada operação
// 8) STATUS VISUAL: HUD mostra todas as informações relevantes
//+------------------------------------------------------------------+
